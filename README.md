# 微店订单自动化导出工具 (V3 - Playwright & Asyncio 高性能重构版)

本项目是一个使用Python实现的、工业级的自动化工具。它通过现代异步技术栈，实现了对微店订单数据的高速采集、高并发截图处理，并将最终结果导出为图文并茂的、格式精美的Excel报告。

V3版本是对V2版本的彻底重构，用 `Playwright` + `Asyncio` 替代了原有的 `Selenium-wire` + `多线程` 模型，带来了在**性能、稳定性、健壮性和可维护性**上的革命性飞跃。

---

## ✨ V3 版本核心特性

- **三阶段解耦架构**: 沿用了V2成功的松耦合设计，将复杂流程拆分为三个独立的、职责单一的模块：
    1.  **采集 (`collector_async.py`)**: 高速捕获XHR请求，将原始订单数据快速存入SQLite数据库。
    2.  **处理 (`screenshotter_async.py`)**: 从数据库读取任务，使用 `BrowserContext` 池和 `asyncio` 并发模型，高速并行截图。
    3.  **导出 (`export_async.py`)**: 从数据库读取已完成的数据，生成最终的Excel报告。

- **异步核心与极致性能**:
    - **完全异步化**: 整个项目基于 `asyncio` 的事件循环构建，采用非阻塞I/O，最大化CPU利用率，从根本上消除了多线程模型中的性能瓶颈。
    - **性能怪兽**: 截图模块实测性能高达 **0.56秒/订单**，是V1版本 (3.79秒/订单) 效率的 **近7倍**。
    - **智能等待**: 全面采用Playwright内置的智能等待机制 (`networkidle`, `wait_for_selector`)，彻底取代了不稳定的固定延时 (`time.sleep`)，实现了速度与稳定性的完美平衡。

- **工业级健壮性**:
    - **无惧崩溃**: 任何一个截图任务的失败都**不会**影响其他并发任务，彻底解决了V2多线程模型中因单个WebDriver崩溃导致所有线程“假死”和“僵尸进程残留”的顽疾。
    - **资源隔离**: 利用 Playwright 的 `BrowserContext` 实现轻量级、完全隔离的并发环境。它的创建和销毁开销极小，且能保证100%的资源清理，杜绝内存泄漏。
    - **数据完整性**: 采用 `(order_id, sub_order_desc)` 的联合唯一键，实现了对订单状态流转的精确记录，既能捕捉每一次变化，又能自动过滤无意义的重复采集数据。

- **精准的截图控制**:
    - 采用“**视口截图 + Pillow精确裁剪**”的经典策略，彻底解决了因页面“无限加载”广告模块导致的截图尺寸不一致和黑边问题，保证了所有截图的格式统一。

---

## 🛠️ 技术栈

- **核心框架**: Python 3.11+
- **浏览器自动化**: Playwright (Async API)
- **并发模型**: Asyncio
- **数据库**: aiosqlite (SQLite的异步驱动)
- **数据处理与导出**: Pandas, XlsxWriter
- **图像处理**: Pillow

---

## 🚀 快速开始

### 1. 环境准备

强烈建议在Python虚拟环境中安装本项目。

```bash
# 创建并激活虚拟环境 (macOS/Linux)
python3 -m venv .venv
source .venv/bin/activate

# 创建并激活虚拟环境 (Windows)
python -m venv .venv
.venv\Scripts\activate

# 安装所有依赖
pip install -r requirements.txt
```
## 2. 完整执行流程 (三步走)

请严格按照以下顺序，依次执行三个独立的脚本。

---

### 第1步：运行异步采集器 (`collector_async.py`)

此脚本负责将订单的元数据抓取到本地的 `tasks.db` 数据库文件中。

*   **配置**：打开 `collector_async.py`，在文件顶部的“用户配置区”，填入最新的 `MY_COOKIE` 和 `CLICKS_TO_PERFORM` (抓取页数)。
*   **执行**:
    ```bash
    python collector_async.py
    ```
*   **产出**：在项目根目录下生成一个 `tasks.db` 文件。

---

### 第2步：运行并行截图器 (`screenshotter_async.py`)

此脚本将从 `tasks.db` 中读取任务，并启动多个并发实例进行截图。

*   **配置**：打开 `screenshotter_async.py`，在文件顶部的“用户配置区”：
    *   填入最新的 `MY_COOKIE`。
    *   根据您的电脑性能，设置 `WORKER_COUNT` (并发数)。建议从 `4` 或 `6` 开始尝试，可逐步增加至CPU核心数附近以探索性能极限。
*   **执行**:
    ```bash
    python screenshotter_async.py
    ```
*   **产出**：在 `screenshots` 文件夹中生成大量截图，并更新 `tasks.db` 文件中的任务状态。

---

### 第3步：运行报告生成器 (`export_async.py`)

此脚本负责读取数据库中所有已完成的任务，生成最终的Excel文件。

*   **配置**：(可选) 打开 `export_async.py`，修改 `OUTPUT_FILENAME` 变量以自定义输出文件名。
*   **执行**:
    ```bash
    python export_async.py
    ```
*   **产出**：在项目根目录下生成最终的 `.xlsx` 报告文件。

---

## 架构设计概览

V3版本的核心是基于异步事件驱动的**生产者-消费者模型**。

*   **`collector_async.py` (生产者):**
    *   作为一个高效的生产者，它通过监听网络事件，快速地生产“任务”（订单数据），并将其放入唯一的“仓库” (`tasks.db` 数据库)。

*   **`screenshotter_async.py` (异步消费者集群):**
    *   **总工头 (main协程):** 负责启动一个浏览器实例，并创建指定数量的“工人”(Worker协程)。
    *   **工人 (Worker协程):** 每个工人都是一个独立的异步循环。它从“仓库”中安全地领取任务，然后创建一个轻量级的、完全隔离的“工作间”(`BrowserContext`)进行加工（截图）。工作完成后，它会彻底销毁“工作间”，不留任何痕迹，然后再去领取下一个任务。

*   **`export_async.py` (报告员):**
    *   在所有工作完成后，报告员会对“仓库”中所有标记为“已完成”的成品进行盘点，并生成一份精美的报告。

这种设计确保了每个组件职责单一，系统健壮、高效，且易于维护和扩展。